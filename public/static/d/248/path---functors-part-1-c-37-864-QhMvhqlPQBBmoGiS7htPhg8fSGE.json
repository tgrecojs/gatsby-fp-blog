{"data":{"markdownRemark":{"html":"<h1>Functors part #1</h1>\n<p>What more fitting of a way to kick of the posts section of functor.xyz then with a bit on functors! Alright. Let's <em>contain</em> our excitement though - we've got some work to do. ðŸ˜Ž</p>\n<p>In this post we're going to learn what requirements must be meant in order for something to be considered a functor.</p>\n<h4>\"You can't put me in a box\"</h4>\n<p>The essence of a <strong>functor data type</strong> is that it is <code>mappable</code>. This simply means that it provides a container (or box) that we can <code>map()</code> through in order to transform values. </p>\n<pre><code>                map(aâ†’b)\n[Box of `a`s] ------> [Box of `b`s]\n</code></pre>\n<p>Hmmm.... A container that we can map through. ðŸ¤” Sounds kinda familiar, right? Well that's because it is! JavaScript's <code>Array []</code> type is a functor. Whether you've realized it or not you have been using functors all along!</p>\n<h5>Testing <code>map</code></h5>\n<p>Below we see the the functor <code>a</code> which is a single element array <code>[10]</code>. Our second functor <code>b</code> is then created using JavaScript's built-in <code>Array.prototype.map</code> method.</p>\n<pre><code class=\"language-javascript\">const doubleIt = x => x * 2;\n\nconst functor = [10];\nconst x = functor.map(doubleIt);\nconst y = functor.map(x => x * 2);\n// testing equality\nconsole.log(x.toString() === y.toString()) // true\n</code></pre>\n<p>It's really that simple. If you're a skeptic like me, then you might be having a hard time buying this. Just sit tight though it will all make sense soon.</p>\n<h3>Category Theory</h3>\n<p>Functional Programming is deeply rooted in category theory - here are its basics:</p>\n<ol>\n<li>\n<p><strong>Category</strong>: A collection of objects and arrows between objects.</p>\n<ul>\n<li>\n<p>Objects can be anything.</p>\n<ul>\n<li>ex. <code>[{name: 'Tom', age: 26}]</code>, <code>[10,30]</code>, <code>['$']</code> </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>morphisms</strong></p>\n<ul>\n<li>Arrays </li>\n<li>Example above | ex. <code>A âˆ’fâ†’ B</code> \t</li>\n</ul>\n</li>\n</ol>\n<h4>Functor Laws:</h4>\n<p>There two functor laws are:</p>\n<ol>\n<li>\n<p><strong>Identity</strong>:</p>\n<ul>\n<li>id function must always <code>map</code> a functor back to the <strong>same value</strong>,</li>\n<li><code>const id = x => x;</code> </li>\n<li><code>[1,2,3].map(id); // returns [1,2,3]</code> </li>\n</ul>\n</li>\n<li>\n<p><strong>Composition</strong>: </p>\n<ul>\n<li>Functors of the same type can be computed in any order and it will not effect their value.</li>\n<li><em>Given <code>g: x => y, f: y => z</code> where <code>x,y,z</code> are collection objects...</em> <strong>there must be a composition that directly <code>X â†’ Z</code></strong>.</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>This composistion law was the same that I was forced to learn in algebra class. It' <strong>associatve</strong> meaning that the order in which it is computer does not matter. Realizing this was a big \"a-ha\" moment when studying functional programming. </p>\n</blockquote>\n<blockquote>\n<p><strong>Ex.:</strong>  (f â—¦ g) â—¦ h = f â—¦ g â—¦ h = f â—¦ (g â—¦ h)</p>\n</blockquote>\n<p>Now that we know the functor laws lets apply them to another array. Below we have the following:</p>\n<ol>\n<li><code>f</code> takes an <code>x</code> and divides by <code>.5</code></li>\n<li><code>g</code> takes an <code>x</code> and multiplies by <code>16</code></li>\n<li><code>data</code> is a functor containing 4 values.</li>\n</ol>\n<pre><code class=\"language-javascript\">const f = x => x / .5;\nconst g = x => x * 16;\nconst data = [25];\n\n// identity law\nconsole.log(\n    data.toString() === data.map(x => x).toString()\n) // 25 === 25\n\n// composistion law\nconsole.log(\n    functor.map(g).map(f).toString() === functor.map(x => f(g(x))).toString(),\n)\n</code></pre>\n<h4>Creating the <code>Box</code> functor</h4>\n<p>We've seen functors in action and we've learned the rules that they must abide by. Now let's create one for ourselves. </p>\n<p>The <code>Box</code> functor will take a value and retun an object with a <code>map</code> method. When <code>map</code> executes, it will apply it's input <code>fn</code> to the value inside and return it's result wrapped inside of.</p>\n<pre><code class=\"language-javascript\">const Box = value => ({\n    map: fn => Identity(fn(value))\n})\n\n/// traces curried functions\nconst trace = val => {\n    console.log(`value:: ${val}`)\n    return val\n}\n\nconst num = Box(20);\n\n// identity law\nconst id = x => x;\n\nconst x1 = num;\nconst x2 = num.map(id);\n\nx2.map(trace); // value:: 1\nx1.map(trace); // value:: 1\n\n// composistion law f(x) * g(x) = f(g(x))\n</code></pre>\n<h3>Wrap up</h3>\n<p>And thus conclude this intro post on functors. Hopefully you've learned something that you didn't prior to reading this.</p>\n<p>Need Improvemen? Give me a call!</p>","frontmatter":{"title":"Functors: Part 1"}}},"pageContext":{"pathSlug":"/functors-part-1","prev":{"frontmatter":{"path":"/third-post","title":"Post C","tags":["this","other"]}},"next":null}}